{"version":3,"names":["stylesCss","ZMenuSectionStyle0","ZMenuSection","this","currentIndex","currentCanvasOpenStatus","canvasOpenStatusChanged","e","detail","handleKeyDown","code","KeyboardCode","ENTER","open","handleNavigationSideArrow","handleArrowsNav","ARROW_RIGHT","ARROW_LEFT","nextElement","hostElement","parentElement","nextElementSibling","menuButton","shadowRoot","querySelector","console","log","focus","setAttribute","prevElement","previousElementSibling","menuItems","Array","from","querySelectorAll","preventDefault","stopPropagation","ARROW_DOWN","ARROW_UP","nextFocusableItem","forEach","item","getNextItem","ESC","focusToParentAndCloseMenu","shiftKey","TAB","direction","length","toggle","hasContent","opened","emit","closed","handleClick","ev","contains","target","checkContent","onLabelSlotChange","labelElement","assignedElements","dataset","text","innerText","focusFirstSectionItemOnKeyUp","firstElement","componentWillLoad","render","h","Host","key","role","class","onClick","bind","onKeyUp","onSlotchange","name"],"sources":["src/components/z-menu-section/styles.css?tag=z-menu-section&encapsulation=shadow","src/components/z-menu-section/index.tsx"],"sourcesContent":[":host {\n  display: inline-flex;\n  flex-direction: column;\n  align-items: flex-start;\n  justify-content: center;\n  padding: 0;\n  font-family: var(--font-family-sans);\n}\n\n:host,\n::slotted(*),\n* {\n  box-sizing: border-box;\n}\n\n::slotted(a) {\n  text-decoration: none;\n}\n\n::slotted(*) {\n  color: var(--color-default-text);\n  font-family: var(--font-family-sans);\n  font-weight: var(--font-rg);\n}\n\n:host(:is([active], [open])) .label,\n.label:hover {\n  border-color: var(--color-secondary01);\n}\n\n:host(:is([active], [open])) .label ::slotted(*),\n.label:focus:focus-visible ::slotted(*),\n.label:hover ::slotted(*) {\n  font-weight: var(--font-bd);\n}\n\n.label {\n  display: flex;\n  width: 100%;\n  align-items: center;\n  padding: calc(var(--space-unit) * 2) calc(var(--space-unit) / 2);\n  border: 0;\n  border-bottom: var(--border-size-small) solid var(--color-surface05);\n  margin: 0;\n  background: transparent;\n  border-radius: 0;\n  cursor: pointer;\n  text-align: left;\n}\n\n::slotted([data-text]) {\n  display: inline-flex;\n  flex-direction: column;\n}\n\n/* Trick to prevent layout shifts on font-weight changes.\nThe trick is to put an hidden copy of the text already set to bold,\nso the needed space is correctly calculated before any hover/active state changes the\nfont-weight of the real text.\nThe hidden text has an height of 0px so it can expand the width without changing the height\nwhen placed below the real text using `flex-direction: column`. */\n::slotted([data-text])::after {\n  overflow: hidden;\n  height: 0;\n  content: attr(data-text);\n  content: attr(data-text) / \"\";\n  font-weight: var(--font-bd);\n  pointer-events: none;\n  user-select: none;\n  visibility: hidden;\n}\n\n@media speech {\n  ::slotted([data-text])::after {\n    display: none;\n  }\n}\n\n.label ::slotted(*) {\n  width: 100%;\n  margin: 0;\n  font-size: var(--font-size-3);\n  line-height: 1.25;\n}\n\n.label:focus:focus-visible {\n  box-shadow: var(--shadow-focus-primary);\n  outline: none;\n}\n\n.label z-icon {\n  margin-left: calc(var(--space-unit) * 4);\n  fill: var(--color-default-icon);\n}\n\n.items {\n  display: flex;\n  width: 100%;\n  flex-direction: column;\n  padding: calc(var(--space-unit) / 2);\n  padding-bottom: calc(var(--space-unit) * 1.5);\n}\n\n.items > ::slotted([slot=\"section\"]) {\n  display: inline-flex;\n  padding: calc(var(--space-unit) / 2);\n  margin: 0;\n  font-size: var(--font-size-2);\n  line-height: 1.4;\n  outline: none;\n}\n\n.items > ::slotted([slot=\"section\"]:focus:focus-visible) {\n  box-shadow: var(--shadow-focus-primary);\n  color: var(--color-secondary01);\n}\n\n.items > ::slotted([slot=\"section\"]:hover),\n.items > ::slotted([slot=\"section\"]:focus:focus-visible),\n.items > ::slotted([slot=\"section\"][active]) {\n  color: var(--color-secondary01);\n  font-weight: var(--font-bd);\n}\n","import {Component, Element, Event, EventEmitter, Host, Listen, Prop, State, h} from \"@stencil/core\";\nimport {KeyboardCode} from \"../../beans\";\n\n/**\n * A component to create submenus inside the ZMenu.\n * @slot - Label of the menu section.\n * @slot item - Single entry of the section. Set the same slot name to different items to put many of them. Add the `active` attribute to a slotted item to highlight it.\n */\n@Component({\n  tag: \"z-menu-section\",\n  styleUrl: \"styles.css\",\n  shadow: true,\n})\nexport class ZMenuSection {\n  @Element() hostElement: HTMLZMenuSectionElement;\n\n  /** Active state */\n  @Prop({reflect: true})\n  active?: boolean;\n\n  @State()\n  open: boolean;\n\n  @State()\n  hasContent: boolean;\n\n  /** The section has been opened. */\n  @Event()\n  opened: EventEmitter;\n\n  /** The section has been closed. */\n  @Event()\n  closed: EventEmitter;\n\n  private currentIndex = -1;\n\n  private currentCanvasOpenStatus = false;\n\n  @Listen(\"canvasOpenStatusChanged\", {target: \"document\"})\n  canvasOpenStatusChanged(e: CustomEvent): void {\n    this.currentCanvasOpenStatus = e.detail;\n  }\n\n  @Listen(\"keydown\")\n  handleKeyDown(e: KeyboardEvent): void {\n    if (e.code === KeyboardCode.ENTER) {\n      return;\n    }\n\n    if (this.open && !this.currentCanvasOpenStatus) {\n      this.handleNavigationSideArrow(e);\n    }\n\n    this.handleArrowsNav(e);\n  }\n\n  private handleNavigationSideArrow(e: KeyboardEvent): void {\n    if (e.code !== KeyboardCode.ARROW_RIGHT && e.code !== KeyboardCode.ARROW_LEFT) {\n      return;\n    }\n    if (e.code === KeyboardCode.ARROW_RIGHT) {\n      const nextElement = this.hostElement.parentElement.nextElementSibling;\n      if (nextElement) {\n        const menuButton = nextElement.shadowRoot.querySelector(\".menu-label\") as HTMLElement;\n        console.log(this.hostElement.parentElement);\n        menuButton.focus();\n      }\n      this.open = false;\n      nextElement.setAttribute(\"open\", \"true\");\n    } else if (e.code === KeyboardCode.ARROW_LEFT) {\n      const prevElement = this.hostElement.parentElement.previousElementSibling;\n      if (prevElement) {\n        const menuButton = prevElement.shadowRoot.querySelector(\".menu-label\") as HTMLElement;\n        menuButton.focus();\n      }\n      prevElement.setAttribute(\"open\", \"true\");\n      this.open = false;\n    }\n  }\n\n  private handleArrowsNav(e: KeyboardEvent): void {\n    const menuItems = Array.from(this.hostElement.querySelectorAll('[slot=\"section\"]')) as HTMLElement[];\n    if (this.open) {\n      e.preventDefault();\n      e.stopPropagation();\n      if (e.code === KeyboardCode.ARROW_DOWN || e.code === KeyboardCode.ARROW_UP) {\n        let nextFocusableItem: HTMLElement;\n        // INFO: reset focus on all menu items\n        menuItems.forEach((item: HTMLElement) => item.setAttribute(\"tabindex\", \"-1\"));\n\n        if (e.code === KeyboardCode.ARROW_DOWN) {\n          nextFocusableItem = this.getNextItem(menuItems, 1);\n        } else if (e.code === KeyboardCode.ARROW_UP) {\n          nextFocusableItem = this.getNextItem(menuItems, -1);\n        }\n\n        if (nextFocusableItem) {\n          nextFocusableItem.setAttribute(\"tabindex\", \"0\");\n          nextFocusableItem.focus();\n        }\n      } else if (e.code === KeyboardCode.ESC) {\n        this.focusToParentAndCloseMenu();\n      } else if (e.shiftKey && e.code === KeyboardCode.TAB) {\n        this.focusToParentAndCloseMenu();\n      }\n    }\n  }\n\n  private getNextItem(menuItems: HTMLElement[], direction: number): HTMLElement {\n    if (this.currentIndex === -1) {\n      this.currentIndex = direction === 1 ? 0 : menuItems.length - 1;\n\n      return menuItems[this.currentIndex];\n    }\n\n    this.currentIndex = (this.currentIndex + direction + menuItems.length) % menuItems.length;\n\n    return menuItems[this.currentIndex];\n  }\n\n  private focusToParentAndCloseMenu(): void {\n    const menuButton = this.hostElement.shadowRoot.querySelector(\"button\") as HTMLElement;\n    menuButton.focus();\n    this.currentIndex = -1;\n    this.open = false;\n  }\n\n  private toggle(): void {\n    if (!this.hasContent) {\n      return;\n    }\n\n    this.open = !this.open;\n    this.open ? this.opened.emit() : this.closed.emit();\n  }\n\n  /** Close the list when a click is performed outside of this Element. */\n  @Listen(\"click\", {target: \"document\"})\n  handleClick(ev: MouseEvent): void {\n    if (!this.open || this.hostElement.contains(ev.target as Node)) {\n      return;\n    }\n\n    this.open = false;\n    this.closed.emit();\n  }\n\n  /**\n   * Check if some content slot is set.\n   */\n  private checkContent(): void {\n    this.hasContent = this.hostElement.querySelectorAll('[slot=\"section\"]').length > 0;\n  }\n\n  /**\n   * Sets slotted item text as `data-text` attribute value, to let CSS use it through `attr()`.\n   * @param ev Slotchange event\n   */\n  private onLabelSlotChange(ev: Event): void {\n    const labelElement = (ev.target as HTMLSlotElement).assignedElements()[0] as HTMLElement;\n    labelElement.dataset.text = labelElement?.innerText || null;\n  }\n\n  private focusFirstSectionItemOnKeyUp(): void {\n    const firstElement = this.hostElement.querySelectorAll('[slot=\"section\"]')[0] as HTMLElement;\n    if (firstElement) {\n      firstElement.focus();\n      this.currentIndex = 0;\n    }\n  }\n\n  componentWillLoad(): void {\n    this.checkContent();\n  }\n\n  render(): HTMLZMenuSectionElement {\n    return (\n      <Host\n        role=\"menu\"\n        open={this.open}\n      >\n        <button\n          class=\"label\"\n          aria-pressed={this.open ? \"true\" : \"false\"}\n          onClick={this.toggle.bind(this)}\n          onKeyUp={this.focusFirstSectionItemOnKeyUp.bind(this)}\n        >\n          <slot onSlotchange={this.onLabelSlotChange.bind(this)}></slot>\n          {this.hasContent && <z-icon name={this.open ? \"chevron-up\" : \"chevron-down\"} />}\n        </button>\n        {this.open && (\n          <div class=\"items\">\n            <slot\n              name=\"section\"\n              onSlotchange={this.checkContent.bind(this)}\n            ></slot>\n          </div>\n        )}\n      </Host>\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]}