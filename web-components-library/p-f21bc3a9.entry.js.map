{"version":3,"names":["stylesCss","ZPopoverStyle0","DOCUMENT_ELEMENT","document","documentElement","getParentElement","element","parentNode","shadowRoot","host","parentElement","findScrollableParent","parent","overflow","overflowX","overflowY","window","getComputedStyle","scrollHeight","clientHeight","scrollWidth","clientWidth","computeOffset","targetParentOffset","rect","getBoundingClientRect","width","height","top","left","offsetParent","offsetLeft","body","scrollY","offsetTop","DOMMatrix","style","transform","webkitTransform","domMatrix","m41","m42","parentWidth","parentHeight","innerWidth","innerHeight","offsetWidth","offsetHeight","right","bottom","ZPopover","PopoverPosition","AUTO","closePopoverWithKeyboard","e","this","closable","key","KeyboardCode","ESC","open","handleOutsideClick","composedPath","includes","target","triggerElemClicked","bindTo","HTMLElement","contains","closest","stopPropagation","positionChange","emit","position","currentPosition","validatePosition","newValue","Object","values","onOpen","cancelAnimationFrame","animationFrameRequestId","setPosition","requestAnimationFrame","hasAttribute","removeAttribute","undefined","openChange","disconnectedCallback","ownerDocument","querySelector","scrollContainer","scrollingBoundingRect","offsetContainer","relativeBoundingRect","boundingRect","scrollTop","scrollLeft","overflowBottom","Math","max","overflowRight","availableTop","min","availableBottom","availableLeft","availableRight","availableHeight","availableWidth","positions","push","LEFT","RIGHT","unshift","TOP","BOTTOM","join","offsetRight","offsetBottom","offsetModifier","center","sizeModifier","TOP_RIGHT","maxHeight","maxWidth","TOP_LEFT","BOTTOM_RIGHT","BOTTOM_LEFT","RIGHT_BOTTOM","RIGHT_TOP","LEFT_BOTTOM","LEFT_TOP","setAttribute","componentWillLoad","render","h"],"sources":["src/components/z-popover/styles.css?tag=z-popover&encapsulation=shadow","src/components/z-popover/index.tsx"],"sourcesContent":[":host {\n  --z-popover-theme--surface: var(--color-surface01);\n  --z-popover-theme--text: var(--color-default-text);\n  --z-popover-padding: 0;\n  --z-popover-shadow-filter: drop-shadow(0 1px 2px var(--shadow-color-base));\n\n  position: relative;\n  display: none;\n  min-width: calc(var(--space-unit) * 8);\n  min-height: calc(var(--space-unit) * 4);\n  align-items: center;\n  justify-content: center;\n  padding: var(--z-popover-padding);\n  background: var(--z-popover-theme--surface);\n  border-radius: var(--border-radius-small);\n  color: var(--z-popover-theme--text);\n  fill: currentcolor;\n  filter: var(--z-popover-shadow-filter);\n  font-family: var(--font-family-sans);\n  text-align: center;\n}\n\n:host([open][current-position]),\n:host([open=\"true\"][current-position]) {\n  display: flex;\n}\n\n:host([center][current-position=\"top\"]),\n:host([center][current-position=\"bottom\"]) {\n  transform: translateX(-50%);\n}\n\n:host([center][current-position=\"right\"]),\n:host([center][current-position=\"left\"]) {\n  transform: translateY(-50%);\n}\n\n:host([current-position^=\"top\"]) {\n  margin: 0 0 var(--space-unit);\n}\n\n:host([current-position^=\"bottom\"]) {\n  margin: var(--space-unit) 0 0;\n}\n\n:host([current-position^=\"left\"]) {\n  margin: 0 var(--space-unit) 0 0;\n}\n\n:host([current-position^=\"right\"]) {\n  margin: 0 0 0 var(--space-unit);\n}\n\n/* Arrow style */\n\n:host([current-position])::before {\n  --arrow-size: 6px;\n  --arrow-edge-offset: calc(100% - var(--space-unit) - (var(--arrow-size) / 2));\n  --arrow-center-x-offset: calc(50% - (var(--arrow-size) / 2));\n  --arrow-center-y-offset: calc(100% - (var(--arrow-size) / 2));\n\n  position: absolute;\n  display: block;\n  width: var(--arrow-size);\n  height: var(--arrow-size);\n  background: var(--z-popover-theme--surface);\n  content: \"\";\n  transform: rotate(45deg);\n}\n\n:host([show-arrow=\"false\"])::before,\n:host(:not([show-arrow]))::before {\n  display: none;\n}\n\n:host([current-position^=\"top\"])::before {\n  top: var(--arrow-center-y-offset);\n}\n\n:host([current-position^=\"bottom\"])::before {\n  bottom: var(--arrow-center-y-offset);\n}\n\n:host([current-position=\"top\"])::before,\n:host([current-position=\"bottom\"])::before {\n  right: var(--arrow-edge-offset);\n}\n\n:host([current-position=\"right\"])::before,\n:host([current-position=\"left\"])::before {\n  bottom: var(--arrow-edge-offset);\n}\n\n:host([current-position=\"right\"])::before {\n  right: var(--arrow-center-y-offset);\n}\n\n:host([current-position=\"left\"])::before {\n  left: var(--arrow-center-y-offset);\n}\n\n:host([current-position=\"top_right\"])::before,\n:host([current-position=\"bottom_right\"])::before {\n  right: var(--arrow-edge-offset);\n}\n\n:host([current-position=\"top_left\"])::before,\n:host([current-position=\"bottom_left\"])::before {\n  left: var(--arrow-edge-offset);\n}\n\n:host([current-position=\"right_top\"])::before,\n:host([current-position=\"left_top\"])::before {\n  top: var(--arrow-edge-offset);\n}\n\n:host([current-position=\"right_top\"])::before,\n:host([current-position=\"right_bottom\"])::before {\n  right: var(--arrow-center-y-offset);\n}\n\n:host([current-position=\"left_top\"])::before,\n:host([current-position=\"left_bottom\"])::before {\n  left: var(--arrow-center-y-offset);\n}\n\n:host([current-position=\"right_bottom\"])::before,\n:host([current-position=\"left_bottom\"])::before {\n  bottom: var(--arrow-edge-offset);\n}\n\n:host([center][current-position=\"top\"])::before,\n:host([center][current-position=\"bottom\"])::before {\n  right: auto;\n  left: var(--arrow-center-x-offset);\n}\n\n:host([center][current-position=\"right\"])::before,\n:host([center][current-position=\"left\"])::before {\n  top: var(--arrow-center-x-offset);\n  bottom: auto;\n}\n\n::slotted(*) {\n  overflow: auto;\n  flex: 1 auto;\n}\n","import {Component, Element, Event, EventEmitter, Listen, Prop, State, Watch, h} from \"@stencil/core\";\nimport {KeyboardCode, PopoverPosition} from \"../../beans\";\n\nconst DOCUMENT_ELEMENT = document.documentElement;\n\nfunction getParentElement(element: Element): Element {\n  if (element.parentNode === element.shadowRoot) {\n    return element.shadowRoot.host;\n  }\n\n  return element.parentElement;\n}\n\n/**\n * Find the closest scrollable parent of a node.\n *\n * @param {Element} element The node\n */\nfunction findScrollableParent(element: Element): Element {\n  let parent = getParentElement(element);\n\n  while (parent && parent !== DOCUMENT_ELEMENT) {\n    const {overflow, overflowX, overflowY} = window.getComputedStyle(parent);\n    if (overflow === \"hidden\" || overflowY === \"hidden\" || overflowX === \"hidden\") {\n      return parent;\n    }\n\n    if (\n      (parent.scrollHeight > parent.clientHeight && overflow !== \"visible\" && overflowY !== \"visible\") ||\n      (parent.scrollWidth > parent.clientWidth && overflow !== \"visible\" && overflowX !== \"visible\")\n    ) {\n      return parent;\n    }\n\n    parent = getParentElement(parent);\n  }\n\n  return DOCUMENT_ELEMENT;\n}\n\n/**\n * Calculate computed offset.\n * It includes matrix transformations.\n * @param element The target element.\n * @param targetParentOffset The relative offset parent.\n * @return A client rect object.\n */\nfunction computeOffset(element: HTMLElement, targetParentOffset?: HTMLElement): Record<string, number> {\n  const rect = element.getBoundingClientRect();\n  const width = rect.width;\n  const height = rect.height;\n\n  let top = 0;\n  let left = 0;\n  let offsetParent = element;\n  while (offsetParent && offsetParent != targetParentOffset) {\n    left += offsetParent.offsetLeft;\n\n    // document.body sometimes has offsetTop == 0 but still has an\n    // offset because of children margins!\n    if (offsetParent === document.body) {\n      top += offsetParent.getBoundingClientRect().top + window.scrollY;\n    } else {\n      top += offsetParent.offsetTop;\n    }\n\n    if (window.DOMMatrix) {\n      const style = window.getComputedStyle(offsetParent);\n      const transform = style.transform || style.webkitTransform;\n      const domMatrix = new DOMMatrix(transform);\n      if (domMatrix) {\n        left += domMatrix.m41;\n        if (offsetParent !== document.body) {\n          top += domMatrix.m42;\n        }\n      }\n    }\n\n    if (!offsetParent.offsetParent) {\n      break;\n    }\n\n    offsetParent = offsetParent.offsetParent as HTMLElement;\n  }\n\n  let parentWidth: number;\n  let parentHeight: number;\n  if (offsetParent === document.body) {\n    parentWidth = window.innerWidth;\n    parentHeight = window.innerHeight;\n  } else {\n    parentWidth = offsetParent.offsetWidth;\n    parentHeight = offsetParent.offsetHeight;\n  }\n\n  const right = parentWidth - left - rect.width;\n  const bottom = parentHeight - top - rect.height;\n\n  return {top, right, bottom, left, width, height};\n}\n\n/**\n * Popover component.\n *\n * @cssprop --z-popover-theme--surface - background color of the popover.\n * @cssprop --z-popover-theme--text - foreground color of the popover.\n * @cssprop --z-popover-padding - padding of the popover.\n * @cssprop --z-popover-shadow-filter - drop-shadow filter of the popover. Defaults to `drop-shadow(0 1px 2px var(--shadow-color-base))`.\n */\n@Component({\n  tag: \"z-popover\",\n  styleUrl: \"styles.css\",\n  shadow: true,\n})\nexport class ZPopover {\n  /** Popover position. */\n  @Prop({reflect: true})\n  position: PopoverPosition = PopoverPosition.AUTO;\n\n  /**\n   * The open state of the popover.\n   */\n  @Prop({reflect: true, mutable: true})\n  open = false;\n\n  /**\n   * The selector or the element bound with the popover.\n   * If string css selector is provided make sure to use a valid selector.\n   */\n  @Prop()\n  bindTo?: string | HTMLElement;\n\n  /**\n   * Whether to show popover's arrow.\n   */\n  @Prop({reflect: true})\n  showArrow = false;\n\n  /**\n   * Whether to center the popup on the main side (according to \"position\").\n   */\n  @Prop({reflect: true})\n  center = false;\n\n  /**\n   * If true, the popover can be closed by clicking outside of it or pressing the escape key.\n   * Otherwise, it will be closed only programmatically (by setting `open` to `false`).\n   */\n  @Prop()\n  closable = true;\n\n  /**\n   * The current position of the popover.\n   */\n  @State()\n  currentPosition?: PopoverPosition;\n\n  /**\n   * Position change event.\n   */\n  @Event()\n  positionChange: EventEmitter;\n\n  /**\n   * Open change event.\n   */\n  @Event()\n  openChange: EventEmitter;\n\n  @Element() host: HTMLZPopoverElement;\n\n  private animationFrameRequestId?: number;\n\n  @Listen(\"keyup\", {target: \"window\"})\n  closePopoverWithKeyboard(e: KeyboardEvent): void {\n    if (this.closable && e.key === KeyboardCode.ESC) {\n      this.open = false;\n    }\n  }\n\n  /**\n   * Close the popover when clicking outside of its content.\n   * Stop event propagation if the click was fired by popover's trigger element,\n   * to prevent close and reopen glitches.\n   * @param {MouseEvent} e\n   */\n  @Listen(\"click\", {target: \"body\", capture: true})\n  handleOutsideClick(e: MouseEvent): void {\n    if (!this.closable || !this.open) {\n      return;\n    }\n\n    if (!e.composedPath().includes(this.host)) {\n      const target = e.target as HTMLElement;\n      const triggerElemClicked =\n        this.bindTo instanceof HTMLElement ? this.bindTo.contains(target) : target.closest(this.bindTo);\n      if (triggerElemClicked) {\n        e.stopPropagation();\n      }\n\n      this.open = false;\n      this.positionChange.emit({position: this.currentPosition});\n    }\n  }\n\n  @Watch(\"position\")\n  validatePosition(newValue: PopoverPosition): void {\n    if (newValue && !Object.values(PopoverPosition).includes(newValue as PopoverPosition)) {\n      this.position = PopoverPosition.AUTO;\n    }\n\n    this.currentPosition = this.position;\n    this.positionChange.emit({position: this.currentPosition});\n  }\n\n  /**\n   * Setup popover behaviors on opening.\n   */\n  @Watch(\"open\")\n  onOpen(): void {\n    cancelAnimationFrame(this.animationFrameRequestId);\n    if (this.open) {\n      const setPosition = (): void => {\n        if (this.open) {\n          this.setPosition();\n          this.animationFrameRequestId = requestAnimationFrame(setPosition);\n        }\n      };\n\n      setPosition();\n    } else if (this.host.hasAttribute(\"current-position\")) {\n      this.host.removeAttribute(\"current-position\");\n      this.currentPosition = undefined;\n    }\n\n    this.openChange.emit({open: this.open});\n  }\n\n  disconnectedCallback(): void {\n    cancelAnimationFrame(this.animationFrameRequestId);\n  }\n\n  /**\n   * Set the position of the popover.\n   */\n  private setPosition(): void {\n    let element: HTMLElement;\n    if (typeof this.bindTo === \"string\") {\n      element = this.host.ownerDocument.querySelector(this.bindTo) as HTMLElement;\n    } else if (this.bindTo) {\n      element = this.bindTo;\n    } else {\n      element = this.host.parentElement as HTMLElement;\n    }\n\n    if (!element) {\n      return;\n    }\n\n    const scrollContainer = findScrollableParent(element) as HTMLElement;\n    const scrollingBoundingRect = scrollContainer.getBoundingClientRect();\n    const offsetContainer = this.host.offsetParent as HTMLElement;\n\n    const relativeBoundingRect = offsetContainer\n      ? computeOffset(offsetContainer, scrollContainer)\n      : {top: 0, right: 0, bottom: 0, left: 0};\n    const boundingRect = computeOffset(element, scrollContainer);\n\n    const top = boundingRect.top - scrollContainer.scrollTop;\n    const bottom = scrollingBoundingRect.height - (boundingRect.top + boundingRect.height) + scrollContainer.scrollTop;\n    const left = boundingRect.left - scrollContainer.scrollLeft;\n    const right = scrollingBoundingRect.width - (boundingRect.left + boundingRect.width) + scrollContainer.scrollLeft;\n\n    const overflowBottom = Math.max(0, scrollingBoundingRect.top + scrollingBoundingRect.height - window.innerHeight);\n    const overflowRight = Math.max(0, scrollingBoundingRect.left + scrollingBoundingRect.width - window.innerWidth);\n\n    const availableTop = Math.min(top, top + scrollingBoundingRect.top);\n    const availableBottom = Math.min(bottom, bottom - overflowBottom);\n    const availableLeft = Math.min(left, left + scrollingBoundingRect.left);\n    const availableRight = Math.min(right, right - overflowRight);\n\n    const availableHeight = availableTop + availableBottom + boundingRect.height;\n    const availableWidth = availableLeft + availableRight + boundingRect.width;\n\n    let position = this.currentPosition;\n    const positions: PopoverPosition[] = [];\n    if (this.position === PopoverPosition.AUTO) {\n      /**\n       * The `AUTO` position tries to place the popover in the 'safest' area,\n       * where there's more space available.\n       */\n      if (availableLeft / availableWidth > 0.6) {\n        positions.push(PopoverPosition.LEFT);\n      } else if (availableLeft / availableWidth < 0.4) {\n        positions.push(PopoverPosition.RIGHT);\n      }\n\n      if (availableTop / availableHeight > 0.9) {\n        positions.unshift(PopoverPosition.TOP);\n      } else if (availableTop / availableHeight > 0.6) {\n        positions.push(PopoverPosition.TOP);\n      } else if (availableTop / availableHeight < 0.1) {\n        positions.unshift(PopoverPosition.BOTTOM);\n      } else {\n        positions.push(PopoverPosition.BOTTOM);\n      }\n\n      position = positions.join(\"_\") as PopoverPosition;\n    }\n\n    const style = this.host.style;\n    style.position = \"absolute\";\n\n    const offsetTop = boundingRect.top - relativeBoundingRect.top;\n    const offsetRight = boundingRect.right - relativeBoundingRect.right;\n    const offsetBottom = boundingRect.bottom - relativeBoundingRect.bottom;\n    const offsetLeft = boundingRect.left - relativeBoundingRect.left;\n    const offsetModifier = this.center ? 0.5 : 0;\n    const sizeModifier = this.center ? 0.5 : 0;\n\n    if (position === PopoverPosition.TOP || position === PopoverPosition.TOP_RIGHT) {\n      style.top = \"auto\";\n      style.right = \"auto\";\n      style.bottom = `${offsetBottom + boundingRect.height}px`;\n\n      style.left = `${offsetLeft + boundingRect.width * offsetModifier}px`;\n      style.maxHeight = `${availableTop}px`;\n      if (position === PopoverPosition.TOP_RIGHT) {\n        style.maxWidth = `${availableRight + boundingRect.width * sizeModifier}px`;\n      }\n    } else if (position === PopoverPosition.TOP_LEFT) {\n      style.top = \"auto\";\n      style.right = `${offsetRight + boundingRect.width * offsetModifier}px`;\n      style.bottom = `${offsetBottom + boundingRect.height}px`;\n      style.left = \"auto\";\n      style.maxWidth = `${availableLeft}px`;\n      style.maxHeight = `${availableTop}px`;\n    } else if (position === PopoverPosition.BOTTOM || position === PopoverPosition.BOTTOM_RIGHT) {\n      style.top = `${offsetTop + boundingRect.height}px`;\n      style.right = \"auto\";\n      style.bottom = \"auto\";\n      style.left = `${offsetLeft + boundingRect.width * offsetModifier}px`;\n      style.maxHeight = `${availableBottom}px`;\n      if (position === PopoverPosition.BOTTOM_RIGHT) {\n        style.maxWidth = `${availableRight + boundingRect.width * sizeModifier}px`;\n      }\n    } else if (position === PopoverPosition.BOTTOM_LEFT) {\n      style.top = `${offsetTop + boundingRect.height}px`;\n      style.right = `${offsetRight + boundingRect.width * offsetModifier}px`;\n      style.bottom = \"auto\";\n      style.left = \"auto\";\n      style.maxWidth = `${availableLeft}px`;\n      style.maxHeight = `${availableBottom}px`;\n    } else if (position === PopoverPosition.RIGHT || position === PopoverPosition.RIGHT_BOTTOM) {\n      style.top = `${offsetTop + boundingRect.height * offsetModifier}px`;\n      style.right = \"auto\";\n      style.bottom = \"auto\";\n      style.left = `${offsetLeft + boundingRect.width}px`;\n      style.maxWidth = `${availableRight}px`;\n      style.maxHeight = `${availableBottom + boundingRect.height * sizeModifier}px`;\n    } else if (position === PopoverPosition.RIGHT_TOP) {\n      style.top = \"auto\";\n      style.right = \"auto\";\n      style.bottom = `${offsetBottom + boundingRect.height * offsetModifier}px`;\n      style.left = `${offsetLeft + boundingRect.width}px`;\n      style.maxWidth = `${availableRight}px`;\n      style.maxHeight = `${availableTop + boundingRect.height * sizeModifier}px`;\n    } else if (position === PopoverPosition.LEFT || position === PopoverPosition.LEFT_BOTTOM) {\n      style.top = `${offsetTop + boundingRect.height * offsetModifier}px`;\n      style.right = `${offsetRight + boundingRect.width}px`;\n      style.bottom = \"auto\";\n      style.left = \"auto\";\n      style.maxWidth = `${availableLeft}px`;\n      style.maxHeight = `${availableBottom + boundingRect.height * sizeModifier}px`;\n    } else if (position === PopoverPosition.LEFT_TOP) {\n      style.top = \"auto\";\n      style.right = `${offsetRight + boundingRect.width}px`;\n      style.bottom = `${offsetBottom + boundingRect.height * offsetModifier}px`;\n      style.left = \"auto\";\n      style.maxWidth = `${availableLeft}px`;\n      style.maxHeight = `${availableTop + boundingRect.height * sizeModifier}px`;\n    }\n\n    this.currentPosition = position || this.position;\n    this.host.setAttribute(\"current-position\", this.currentPosition);\n  }\n\n  componentWillLoad(): void {\n    this.validatePosition(this.position);\n    this.onOpen();\n  }\n\n  render(): HTMLSlotElement {\n    return <slot></slot>;\n  }\n}\n"],"mappings":"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","ignoreList":[]}