{"version":3,"names":["stylesCss","ZMenuStyle0","ZMenu","toggle","this","hasContent","open","opened","emit","closed","handleClick","ev","floating","hostElement","contains","target","reflow","canvasOpenStatusChanged","e","currentCanvasOpenStatus","detail","handleKeyDown","code","KeyboardCode","ENTER","handleNavigationSideArrow","handleArrowsNav","ARROW_RIGHT","ARROW_LEFT","nextElement","nextElementSibling","firstMenuItem","firstElMenu","shadowRoot","querySelector","focus","tagName","menuButton","children","length","setAttribute","prevElement","previousElementSibling","lastElMenuItem","lastElMenu","menuItems","Array","from","querySelectorAll","newMenuItems","map","el","preventDefault","stopPropagation","ARROW_DOWN","ARROW_UP","nextFocusableItem","forEach","item","getNextItem","ESC","focusToParentAndCloseMenu","shiftKey","TAB","direction","currentIndex","onOpenChanged","cancelAnimationFrame","raf","constructor","hostRef","bind","checkContent","onLabelSlotChange","onItemsChange","componentWillLoad","parentElement","labelElement","assignedElements","dataset","text","textContent","live","content","style","left","getBoundingClientRect","widthPx","getComputedStyle","width","parseFloat","replace","safeScrollbarSpace","Math","min","window","innerWidth","requestAnimationFrame","hasHeader","items","focusFirstItemOnKeyUp","firstElement","renderMenuLabel","h","class","onClick","onKeyUp","onSlotchange","name","render","Host","key","ref","role"],"sources":["src/components/z-menu/styles.css?tag=z-menu&encapsulation=shadow","src/components/z-menu/index.tsx"],"sourcesContent":[":host,\n::slotted(*),\n* {\n  box-sizing: border-box;\n  outline: none;\n}\n\n:host {\n  position: relative;\n  display: inline-flex;\n  flex-direction: column;\n  flex-shrink: 0;\n\n  --z-menu-label-color: var(--color-default-text);\n}\n\n::slotted(a) {\n  text-decoration: none;\n}\n\n::slotted(*) {\n  color: var(--color-default-text);\n  font-family: var(--font-family-sans);\n  font-weight: var(--font-rg);\n}\n\n.menu-label {\n  width: 100%;\n  padding: 0;\n  border: 0;\n  margin: 0;\n  background: transparent;\n  border-radius: 0;\n  color: inherit;\n  outline: none;\n  text-align: left;\n}\n\n.menu-wrapper {\n  display: flex;\n  align-items: center;\n}\n\n.menu-wrapper:focus-visible,\n.menu-label-content:focus-visible,\nbutton:focus-visible {\n  outline: none;\n}\n\nbutton.menu-label {\n  cursor: pointer;\n}\n\n.menu-label:focus-within {\n  z-index: 1;\n  box-shadow: var(--shadow-focus-primary);\n}\n\n.menu-label .menu-label-content {\n  position: relative;\n  display: flex;\n  height: 30px;\n  align-items: center;\n}\n\n:host(:is([active], [open])) .menu-label-content,\n.menu-label:focus-within .menu-label-content {\n  color: var(--color-primary01);\n  font-weight: var(--font-bd);\n}\n\n:host(:is([active], [open])) .menu-label-content ::slotted(*),\n.menu-label:focus-within .menu-label-content ::slotted(*),\n.menu-label:focus-within .menu-label-content z-icon {\n  color: var(--color-primary01);\n  letter-spacing: normal;\n}\n\n:host .menu-label .menu-label-content ::slotted(*:not([slot]):focus:focus-visible) {\n  box-shadow: none !important;\n}\n\n/* border */\n:host(:is([active], [open], [vertical-context])) .menu-label .menu-label-content::after,\n.menu-label .menu-label-content:hover::after,\n.menu-label:focus-within .menu-label-content::after {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  content: \"\";\n  pointer-events: none;\n}\n\n:host([vertical-context]) .menu-label-content::after {\n  height: var(--border-size-small);\n  background-color: var(--color-surface03);\n}\n\n:host(:is([active], [open])) .menu-label .menu-label-content::after,\n.menu-label .menu-label-content:hover::after,\n.menu-label:focus-within .menu-label-content::after {\n  height: var(--border-size-large);\n  background-color: var(--color-secondary01);\n}\n\n/* Prevents layout shifts on font-weight changes.\nThe trick is to put an hidden copy of the text already set to bold,\nso the needed space is correctly calculated before any hover/active state changes the\nfont-weight of the real text.\nThe hidden text has an height of 0px so it can expand the width without changing the height\nwhen placed below the real text using `flex-direction: column`. */\n::slotted([data-text])::after {\n  height: 0;\n  content: attr(data-text);\n  content: attr(data-text) / \"\";\n  font-weight: var(--font-bd);\n  letter-spacing: normal;\n  pointer-events: none;\n  user-select: none;\n  visibility: hidden;\n}\n\n@media speech {\n  ::slotted([data-text])::after {\n    display: none;\n  }\n}\n\n::slotted([data-text]) {\n  display: inline-flex;\n  flex-direction: column;\n}\n\n.menu-label .menu-label-content ::slotted(*) {\n  display: inline-flex;\n  width: 100%;\n  min-width: fit-content;\n  margin: 0;\n  appearance: none;\n  color: var(--z-menu-label-color);\n  font-family: var(--font-family-sans);\n  font-size: var(--font-size-3);\n  font-weight: inherit;\n  outline: none;\n}\n\n.menu-label .menu-label-content ::slotted(*),\n.menu-label .menu-label-content z-icon {\n  padding: var(--space-unit) 0;\n}\n\n.menu-label .menu-label-content z-icon {\n  margin-left: calc(var(--space-unit) * 1.5);\n  fill: currentcolor;\n}\n\n.content {\n  background: var(--color-surface01);\n}\n\n:host(:not([open])) .content {\n  display: none;\n}\n\n:host([floating]) .content {\n  position: absolute;\n  top: 100%;\n  left: 0;\n  width: 375px;\n  min-width: 100%;\n  max-width: 100vw;\n  padding: var(--space-unit) var(--space-unit) calc(var(--space-unit) * 2);\n  box-shadow: var(--shadow-2);\n}\n\n:host(:not([floating])) .content {\n  width: 100%;\n}\n\n.header {\n  display: flex;\n  align-items: center;\n  padding: var(--space-unit) 0 calc(var(--space-unit) * 2);\n}\n\n.header ::slotted(img[slot=\"header\"]) {\n  width: calc(var(--space-unit) * 11.25);\n  height: auto;\n  object-fit: contain;\n}\n\n.header ::slotted([slot=\"header\"]:not(:first-child)) {\n  margin: auto 0;\n  margin-left: calc(var(--space-unit) * 2.5);\n  font-size: var(--font-size-3);\n  font-weight: var(--font-sb);\n  line-height: 1.5;\n}\n\n.items {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n  background: inherit;\n}\n\n.items > ::slotted([slot=\"item\"]) {\n  width: 100%;\n  margin: 0;\n  font-size: var(--font-size-3);\n  line-height: 1.25;\n  outline: none;\n}\n\n.items > ::slotted([slot=\"item\"]:focus:focus-visible) {\n  box-shadow: var(--shadow-focus-primary);\n}\n\n.items > ::slotted([slot=\"item\"]:not(z-menu-section)) {\n  padding: calc(var(--space-unit) * 2) calc(var(--space-unit) * 0.5);\n  border-bottom: var(--border-size-small) solid var(--color-surface05);\n}\n\n.items > ::slotted([slot=\"item\"]:hover),\n.items > ::slotted([slot=\"item\"]:focus:focus-visible),\n.items > ::slotted([slot=\"item\"]:active) {\n  border-color: var(--color-secondary01);\n  font-weight: var(--font-bd);\n}\n","import {Component, Element, Event, EventEmitter, Host, Listen, Prop, State, Watch, h} from \"@stencil/core\";\nimport {KeyboardCode} from \"../../beans\";\n\n/**\n * @slot - Menu label\n * @slot header - Header to display as the first entry of the open menu.\n * @slot item - Single entry of the section. Can be slotted multiple times to insert items onto the menu. Use `z-menu-section` for submenus.\n * @cssprop --z-menu-label-color - Color of the label's text.\n */\n@Component({\n  tag: \"z-menu\",\n  styleUrl: \"styles.css\",\n  shadow: true,\n})\nexport class ZMenu {\n  @Element() hostElement: HTMLZMenuElement;\n\n  /** Flag to set the active status of the menu. */\n  @Prop({reflect: true})\n  active?: boolean;\n\n  /**\n   * Flag to set the display mode of the list.\n   * If true, the list will be absolutely positioned under the menu label,\n   * stacked beneath it otherwise.\n   */\n  @Prop({reflect: true})\n  floating? = true;\n\n  /** The opening state of the menu. */\n  @Prop({mutable: true, reflect: true})\n  open = false;\n\n  /**\n   * Tells the component that it's placed in a vertical context with other `ZMenu`s (e.g. in the ZAppHeader's offcanvas).\n   * A small border is placed under it as a separator from other elements.\n   */\n  @Prop({reflect: true})\n  verticalContext = false;\n\n  @State()\n  hasHeader: boolean;\n\n  @State()\n  hasContent: boolean;\n\n  private content: HTMLElement;\n\n  /** Animation frame request id. */\n  private raf: number;\n\n  /** The menu has been opened. */\n  @Event()\n  opened: EventEmitter;\n\n  /** The menu has been closed. */\n  @Event()\n  closed: EventEmitter;\n\n  private currentIndex = -1;\n\n  private currentCanvasOpenStatus = false;\n\n  private firstElMenu: HTMLMenuElement;\n\n  private lastElMenu: HTMLMenuElement;\n\n  private toggle(): void {\n    if (!this.hasContent) {\n      return;\n    }\n\n    this.open = !this.open;\n    this.open ? this.opened.emit() : this.closed.emit();\n  }\n\n  /** Close the floating list when a click is performed outside of this Element. */\n  @Listen(\"click\", {target: \"document\"})\n  handleClick(ev: MouseEvent): void {\n    if (!this.floating || !this.open || this.hostElement.contains(ev.target as Element)) {\n      return;\n    }\n\n    this.reflow();\n    this.open = false;\n    this.closed.emit();\n  }\n\n  @Listen(\"canvasOpenStatusChanged\", {target: \"document\"})\n  canvasOpenStatusChanged(e: CustomEvent): void {\n    this.currentCanvasOpenStatus = e.detail;\n  }\n\n  @Listen(\"keydown\")\n  handleKeyDown(e: KeyboardEvent): void {\n    if (e.code === KeyboardCode.ENTER) {\n      return;\n    }\n\n    if (this.open && !this.currentCanvasOpenStatus) {\n      this.handleNavigationSideArrow(e);\n    }\n\n    this.handleArrowsNav(e);\n  }\n\n  private handleNavigationSideArrow(e: KeyboardEvent): void {\n    if (e.code !== KeyboardCode.ARROW_RIGHT && e.code !== KeyboardCode.ARROW_LEFT) {\n      return;\n    }\n\n    if (e.code === KeyboardCode.ARROW_RIGHT) {\n      const nextElement = this.hostElement.nextElementSibling;\n\n      if (!nextElement) {\n        const firstMenuItem = this.firstElMenu.shadowRoot.querySelector(\".menu-label\") as HTMLElement;\n        firstMenuItem.focus();\n        this.open = false;\n      }\n\n      if (nextElement && nextElement.tagName === \"Z-MENU\") {\n        const menuButton = nextElement.shadowRoot.querySelector(\".menu-label\") as HTMLElement;\n        menuButton.focus();\n\n        if (nextElement.children.length > 1) {\n          nextElement.setAttribute(\"open\", \"true\");\n        }\n        this.open = false;\n      }\n    } else if (e.code === KeyboardCode.ARROW_LEFT) {\n      const prevElement = this.hostElement.previousElementSibling;\n      if (prevElement.tagName !== \"Z-MENU\") {\n        const lastElMenuItem = this.lastElMenu.shadowRoot.querySelector(\".menu-label\") as HTMLElement;\n        lastElMenuItem.focus();\n        this.open = false;\n      }\n      if (prevElement && prevElement.tagName === \"Z-MENU\") {\n        const menuButton = prevElement.shadowRoot.querySelector(\".menu-label\") as HTMLElement;\n        menuButton.focus();\n        if (prevElement.children.length > 1) {\n          prevElement.setAttribute(\"open\", \"true\");\n        }\n        this.open = false;\n      }\n    }\n  }\n\n  private handleArrowsNav(e: KeyboardEvent): void {\n    const menuItems = Array.from(this.hostElement.querySelectorAll(\"[slot='item']\")) as HTMLElement[];\n    const newMenuItems = menuItems.map((el) => {\n      if (el.tagName === \"Z-MENU-SECTION\") {\n        return el.shadowRoot.querySelector(\"button\");\n      }\n\n      return el;\n    });\n\n    if (this.open) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (e.code === KeyboardCode.ARROW_DOWN || e.code === KeyboardCode.ARROW_UP) {\n        let nextFocusableItem: HTMLElement;\n        // INFO: reset focus on all menu items\n        newMenuItems.forEach((item: HTMLElement) => item.setAttribute(\"tabindex\", \"-1\"));\n\n        if (e.code === KeyboardCode.ARROW_DOWN) {\n          nextFocusableItem = this.getNextItem(newMenuItems, 1);\n        } else if (e.code === KeyboardCode.ARROW_UP) {\n          nextFocusableItem = this.getNextItem(newMenuItems, -1);\n        }\n\n        if (nextFocusableItem) {\n          nextFocusableItem.setAttribute(\"tabindex\", \"0\");\n          nextFocusableItem.focus();\n        }\n      } else if (e.code === KeyboardCode.ESC) {\n        this.focusToParentAndCloseMenu();\n      } else if (e.shiftKey && e.code === KeyboardCode.TAB) {\n        this.focusToParentAndCloseMenu();\n      }\n    }\n  }\n\n  private getNextItem(menuItems: HTMLElement[], direction: number): HTMLElement {\n    if (this.currentIndex === -1) {\n      this.currentIndex = direction === 1 ? 0 : menuItems.length - 1;\n\n      return menuItems[this.currentIndex];\n    }\n\n    this.currentIndex = (this.currentIndex + direction + menuItems.length) % menuItems.length;\n\n    return menuItems[this.currentIndex];\n  }\n\n  private focusToParentAndCloseMenu(): void {\n    const menuButton = this.hostElement.shadowRoot.querySelector(\".menu-label\") as HTMLElement;\n    menuButton.focus();\n    this.currentIndex = -1;\n    this.open = false;\n  }\n\n  @Watch(\"open\")\n  onOpenChanged(): void {\n    if (this.open) {\n      this.reflow(true);\n    } else {\n      cancelAnimationFrame(this.raf);\n    }\n  }\n\n  constructor() {\n    this.toggle = this.toggle.bind(this);\n    this.checkContent = this.checkContent.bind(this);\n    this.onLabelSlotChange = this.onLabelSlotChange.bind(this);\n    this.onItemsChange = this.onItemsChange.bind(this);\n  }\n\n  componentWillLoad(): void {\n    const menuItems = Array.from(this.hostElement.parentElement.querySelectorAll('[slot=\"menu\"]'));\n    this.firstElMenu = menuItems[0] as HTMLMenuElement;\n    this.lastElMenu = menuItems[menuItems.length - 1] as HTMLMenuElement;\n\n    this.checkContent();\n  }\n\n  /**\n   * Sets slotted item text as `data-text` attribute value, to let CSS use it through `attr()`.\n   * @param ev Slotchange event\n   */\n  private onLabelSlotChange(ev: Event): void {\n    const labelElement = (ev.target as HTMLSlotElement).assignedElements()[0] as HTMLElement;\n    labelElement.dataset.text = labelElement?.textContent;\n  }\n\n  /**\n   * Correctly set position of the floating menu in order to prevent overflow.\n   * @param live Should run the method on every refresh frame.\n   */\n  private reflow(live = false): void {\n    if (this.content) {\n      const {style} = this.content;\n      const {left} = this.hostElement.getBoundingClientRect();\n      const widthPx = getComputedStyle(this.content).width;\n      const width = widthPx ? parseFloat(widthPx.replace(\"px\", \"\")) : 375;\n      const safeScrollbarSpace = 30;\n      style.left = `${Math.min(window.innerWidth - left - width - safeScrollbarSpace, 0)}px`;\n    }\n    if (live) {\n      this.raf = requestAnimationFrame(this.reflow.bind(this, live));\n    }\n  }\n\n  /**\n   * Check if some content slot is set.\n   */\n  private checkContent(): void {\n    this.hasHeader = !!this.hostElement.querySelectorAll(\"[slot=header]\").length;\n    this.hasContent = !!this.hostElement.querySelectorAll(\"[slot=item]\").length || this.hasHeader;\n  }\n\n  /**\n   * Set `menuitem` role to all menu items.\n   * Set the item's inner text to the `data-text` attribute (this is for using bold text avoiding layout shifts).\n   */\n  private onItemsChange(): void {\n    this.checkContent();\n    const items = this.hostElement.querySelectorAll<HTMLElement>(\"[slot=item]\");\n    items.forEach((item) => {\n      item.setAttribute(\"role\", \"menuitem\");\n      item.setAttribute(\"tabindex\", \"-1\");\n      item.dataset.text = item.textContent;\n    });\n  }\n\n  private focusFirstItemOnKeyUp(): void {\n    const firstElement = this.hostElement.querySelectorAll(\"[slot='item']\")[0] as HTMLElement;\n    if (firstElement) {\n      firstElement.focus();\n      this.currentIndex = 0;\n    }\n  }\n\n  private renderMenuLabel(): HTMLButtonElement | HTMLDivElement {\n    if (this.hasContent) {\n      return (\n        <div class=\"menu-wrapper\">\n          <button\n            class=\"menu-label\"\n            aria-expanded={this.open ? \"true\" : \"false\"}\n            aria-label={this.open ? \"Chiudi menù\" : \"Apri menù\"}\n            onClick={this.toggle}\n            onKeyUp={this.focusFirstItemOnKeyUp.bind(this)}\n          >\n            <div class=\"menu-label-content\">\n              <slot onSlotchange={this.onLabelSlotChange}></slot>\n              <z-icon name={this.open ? \"chevron-up\" : \"chevron-down\"} />\n            </div>\n          </button>\n        </div>\n      );\n    }\n\n    return (\n      <div class=\"menu-wrapper\">\n        <div class=\"menu-label\">\n          <div class=\"menu-label-content\">\n            <slot onSlotchange={this.onLabelSlotChange}></slot>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  render(): HTMLZMenuElement {\n    return (\n      <Host>\n        {this.renderMenuLabel()}\n\n        {this.hasContent && (\n          <div\n            class=\"content\"\n            ref={(el) => (this.content = el)}\n          >\n            {this.hasHeader && (\n              <header class=\"header\">\n                <slot\n                  name=\"header\"\n                  onSlotchange={this.checkContent}\n                ></slot>\n              </header>\n            )}\n\n            <div\n              class=\"items\"\n              role=\"menu\"\n            >\n              <slot\n                name=\"item\"\n                onSlotchange={this.onItemsChange}\n              ></slot>\n            </div>\n          </div>\n        )}\n      </Host>\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]}