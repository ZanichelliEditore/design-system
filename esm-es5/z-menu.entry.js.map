{"version":3,"names":["stylesCss","ZMenuStyle0","ZMenu","hostRef","this","toggle","bind","checkContent","onLabelSlotChange","onItemsChange","prototype","hasContent","open","opened","emit","closed","handleClick","ev","floating","hostElement","contains","target","reflow","onOpenChanged","cancelAnimationFrame","raf","componentWillLoad","labelElement","assignedElements","dataset","text","textContent","live","content","style","left","getBoundingClientRect","widthPx","getComputedStyle","width","parseFloat","replace","safeScrollbarSpace","concat","Math","min","window","innerWidth","requestAnimationFrame","hasHeader","querySelectorAll","length","items","forEach","item","setAttribute","renderMenuLabel","h","class","onClick","onSlotchange","name","render","_this","Host","key","ref","el","role"],"sources":["src/components/z-menu/styles.css?tag=z-menu&encapsulation=shadow","src/components/z-menu/index.tsx"],"sourcesContent":[":host,\n::slotted(*),\n* {\n  box-sizing: border-box;\n}\n\n:host {\n  position: relative;\n  display: inline-flex;\n  flex-direction: column;\n\n  --z-menu-label-color: var(--color-default-text);\n}\n\n::slotted(a) {\n  text-decoration: none;\n}\n\n::slotted(*) {\n  color: var(--color-default-text);\n  font-family: var(--font-family-sans);\n  font-weight: var(--font-rg);\n}\n\n.menu-label {\n  padding: 0;\n  border: 0;\n  margin: 0;\n  background: transparent;\n  border-radius: 0;\n  color: inherit;\n  outline: none;\n  text-align: left;\n}\n\nbutton.menu-label {\n  cursor: pointer;\n}\n\n.menu-label:focus-within {\n  z-index: 1;\n  padding-right: calc(var(--space-unit) * 0.5);\n  padding-left: calc(var(--space-unit) * 0.5);\n  margin-right: calc(var(--space-unit) * -0.5);\n  margin-left: calc(var(--space-unit) * -0.5);\n  box-shadow: var(--shadow-focus-primary);\n}\n\n.menu-label .menu-label-content {\n  position: relative;\n  display: flex;\n  align-items: center;\n}\n\n:host(:is([active], [open])) .menu-label-content,\n.menu-label:focus-within .menu-label-content {\n  font-weight: var(--font-bd);\n}\n\n:host(:is([active], [open])) .menu-label-content ::slotted(*),\n.menu-label:focus-within .menu-label-content ::slotted(*) {\n  letter-spacing: normal;\n}\n\n:host .menu-label .menu-label-content ::slotted(*:not([slot]):focus:focus-visible) {\n  box-shadow: none !important;\n}\n\n/* border */\n:host(:is([active], [open], [vertical-context])) .menu-label .menu-label-content::after,\n.menu-label .menu-label-content:hover::after,\n.menu-label:focus-within .menu-label-content::after {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  content: \"\";\n  pointer-events: none;\n}\n\n:host([vertical-context]) .menu-label-content::after {\n  height: var(--border-size-small);\n  background-color: var(--color-surface03);\n}\n\n:host(:is([active], [open])) .menu-label .menu-label-content::after,\n.menu-label .menu-label-content:hover::after,\n.menu-label:focus-within .menu-label-content::after {\n  height: var(--border-size-large);\n  background-color: var(--color-secondary01);\n}\n\n/* Prevents layout shifts on font-weight changes.\nThe trick is to put an hidden copy of the text already set to bold,\nso the needed space is correctly calculated before any hover/active state changes the\nfont-weight of the real text.\nThe hidden text has an height of 0px so it can expand the width without changing the height\nwhen placed below the real text using `flex-direction: column`. */\n::slotted([data-text])::after {\n  height: 0;\n  content: attr(data-text);\n  content: attr(data-text) / \"\";\n  font-weight: var(--font-bd);\n  letter-spacing: normal;\n  pointer-events: none;\n  user-select: none;\n  visibility: hidden;\n}\n\n@media speech {\n  ::slotted([data-text])::after {\n    display: none;\n  }\n}\n\n::slotted([data-text]) {\n  display: inline-flex;\n  flex-direction: column;\n}\n\n.menu-label .menu-label-content ::slotted(*) {\n  display: inline-flex;\n  width: 100%;\n  margin: 0;\n  appearance: none;\n  color: var(--z-menu-label-color);\n  font-family: var(--font-family-sans);\n  font-size: var(--font-size-5);\n  font-weight: inherit;\n  letter-spacing: 0.36px; /* increasing the letter spacing of the regular text helps reduce the size difference between regular and bold text */\n  line-height: 1.2;\n  outline: none;\n}\n\n.menu-label .menu-label-content ::slotted(*),\n.menu-label .menu-label-content z-icon {\n  padding: var(--space-unit) 0;\n}\n\n.menu-label .menu-label-content z-icon {\n  margin-left: calc(var(--space-unit) * 1.5);\n  fill: currentcolor;\n}\n\n.content {\n  background: var(--color-surface01);\n}\n\n:host(:not([open])) .content {\n  display: none;\n}\n\n:host([floating]) .content {\n  position: absolute;\n  top: 100%;\n  left: 0;\n  width: 375px;\n  min-width: 100%;\n  max-width: 100vw;\n  padding: var(--space-unit) var(--space-unit) calc(var(--space-unit) * 2);\n  box-shadow: var(--shadow-2);\n}\n\n:host(:not([floating])) .content {\n  width: 100%;\n}\n\n.header {\n  display: flex;\n  align-items: center;\n  padding: var(--space-unit) 0 calc(var(--space-unit) * 2);\n}\n\n.header ::slotted(img[slot=\"header\"]) {\n  width: calc(var(--space-unit) * 11.25);\n  height: auto;\n  object-fit: contain;\n}\n\n.header ::slotted([slot=\"header\"]:not(:first-child)) {\n  margin: auto 0;\n  margin-left: calc(var(--space-unit) * 2.5);\n  font-size: var(--font-size-3);\n  font-weight: var(--font-sb);\n  line-height: 1.5;\n}\n\n.items {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n  background: inherit;\n}\n\n.items > ::slotted([slot=\"item\"]) {\n  width: 100%;\n  margin: 0;\n  font-size: var(--font-size-3);\n  line-height: 1.25;\n  outline: none;\n}\n\n.items > ::slotted([slot=\"item\"]:focus:focus-visible) {\n  box-shadow: var(--shadow-focus-primary);\n}\n\n.items > ::slotted([slot=\"item\"]:not(z-menu-section)) {\n  padding: calc(var(--space-unit) * 2) calc(var(--space-unit) * 0.5);\n  border-bottom: var(--border-size-small) solid var(--color-surface05);\n}\n\n.items > ::slotted([slot=\"item\"]:hover),\n.items > ::slotted([slot=\"item\"]:focus:focus-visible),\n.items > ::slotted([slot=\"item\"]:active) {\n  border-color: var(--color-secondary01);\n  font-weight: var(--font-bd);\n}\n","import {Component, Element, Event, EventEmitter, Host, Listen, Prop, State, Watch, h} from \"@stencil/core\";\n\n/**\n * @slot - Menu label\n * @slot header - Header to display as the first entry of the open menu.\n * @slot item - Single entry of the section. Can be slotted multiple times to insert items onto the menu. Use `z-menu-section` for submenus.\n * @cssprop --z-menu-label-color - Color of the label's text.\n */\n@Component({\n  tag: \"z-menu\",\n  styleUrl: \"styles.css\",\n  shadow: true,\n})\nexport class ZMenu {\n  @Element() hostElement: HTMLZMenuElement;\n\n  /** Flag to set the active status of the menu. */\n  @Prop({reflect: true})\n  active?: boolean;\n\n  /**\n   * Flag to set the display mode of the list.\n   * If true, the list will be absolutely positioned under the menu label,\n   * stacked beneath it otherwise.\n   */\n  @Prop({reflect: true})\n  floating? = false;\n\n  /** The opening state of the menu. */\n  @Prop({mutable: true, reflect: true})\n  open = false;\n\n  /**\n   * Tells the component that it's placed in a vertical context with other `ZMenu`s (e.g. in the ZAppHeader's offcanvas).\n   * A small border is placed under it as a separator from other elements.\n   */\n  @Prop({reflect: true})\n  verticalContext = false;\n\n  @State()\n  hasHeader: boolean;\n\n  @State()\n  hasContent: boolean;\n\n  private content: HTMLElement;\n\n  /** Animation frame request id. */\n  private raf: number;\n\n  /** The menu has been opened. */\n  @Event()\n  opened: EventEmitter;\n\n  /** The menu has been closed. */\n  @Event()\n  closed: EventEmitter;\n\n  private toggle(): void {\n    if (!this.hasContent) {\n      return;\n    }\n\n    this.open = !this.open;\n    this.open ? this.opened.emit() : this.closed.emit();\n  }\n\n  /** Close the floating list when a click is performed outside of this Element. */\n  @Listen(\"click\", {target: \"document\"})\n  handleClick(ev: MouseEvent): void {\n    if (!this.floating || !this.open || this.hostElement.contains(ev.target as Element)) {\n      return;\n    }\n\n    this.reflow();\n    this.open = false;\n    this.closed.emit();\n  }\n\n  @Watch(\"open\")\n  onOpenChanged(): void {\n    if (this.open) {\n      this.reflow(true);\n    } else {\n      cancelAnimationFrame(this.raf);\n    }\n  }\n\n  constructor() {\n    this.toggle = this.toggle.bind(this);\n    this.checkContent = this.checkContent.bind(this);\n    this.onLabelSlotChange = this.onLabelSlotChange.bind(this);\n    this.onItemsChange = this.onItemsChange.bind(this);\n  }\n\n  componentWillLoad(): void {\n    this.checkContent();\n  }\n\n  /**\n   * Sets slotted item text as `data-text` attribute value, to let CSS use it through `attr()`.\n   * @param ev Slotchange event\n   */\n  private onLabelSlotChange(ev: Event): void {\n    const labelElement = (ev.target as HTMLSlotElement).assignedElements()[0] as HTMLElement;\n    labelElement.dataset.text = labelElement?.textContent;\n  }\n\n  /**\n   * Correctly set position of the floating menu in order to prevent overflow.\n   * @param live Should run the method on every refresh frame.\n   */\n  private reflow(live = false): void {\n    if (this.content) {\n      const {style} = this.content;\n      const {left} = this.hostElement.getBoundingClientRect();\n      const widthPx = getComputedStyle(this.content).width;\n      const width = widthPx ? parseFloat(widthPx.replace(\"px\", \"\")) : 375;\n      const safeScrollbarSpace = 30;\n      style.left = `${Math.min(window.innerWidth - left - width - safeScrollbarSpace, 0)}px`;\n    }\n    if (live) {\n      this.raf = requestAnimationFrame(this.reflow.bind(this, live));\n    }\n  }\n\n  /**\n   * Check if some content slot is set.\n   */\n  private checkContent(): void {\n    this.hasHeader = !!this.hostElement.querySelectorAll(\"[slot=header]\").length;\n    this.hasContent = !!this.hostElement.querySelectorAll(\"[slot=item]\").length || this.hasHeader;\n  }\n\n  /**\n   * Set `menuitem` role to all menu items.\n   * Set the item's inner text to the `data-text` attribute (this is for using bold text avoiding layout shifts).\n   */\n  private onItemsChange(): void {\n    this.checkContent();\n    const items = this.hostElement.querySelectorAll<HTMLElement>(\"[slot=item]\");\n    items.forEach((item) => {\n      item.setAttribute(\"role\", \"menuitem\");\n      item.dataset.text = item.textContent;\n    });\n  }\n\n  private renderMenuLabel(): HTMLButtonElement | HTMLDivElement {\n    if (this.hasContent) {\n      return (\n        <button\n          class=\"menu-label\"\n          aria-expanded={this.open ? \"true\" : \"false\"}\n          aria-label={this.open ? \"Chiudi menù\" : \"Apri menù\"}\n          onClick={this.toggle}\n        >\n          <div class=\"menu-label-content\">\n            <slot onSlotchange={this.onLabelSlotChange}></slot>\n            <z-icon name={this.open ? \"chevron-up\" : \"chevron-down\"} />\n          </div>\n        </button>\n      );\n    }\n\n    return (\n      <div class=\"menu-label\">\n        <div class=\"menu-label-content\">\n          <slot onSlotchange={this.onLabelSlotChange}></slot>\n        </div>\n      </div>\n    );\n  }\n\n  render(): HTMLZMenuElement {\n    return (\n      <Host>\n        {this.renderMenuLabel()}\n\n        {this.hasContent && (\n          <div\n            class=\"content\"\n            ref={(el) => (this.content = el)}\n          >\n            {this.hasHeader && (\n              <header class=\"header\">\n                <slot\n                  name=\"header\"\n                  onSlotchange={this.checkContent}\n                ></slot>\n              </header>\n            )}\n\n            <div\n              class=\"items\"\n              role=\"menu\"\n            >\n              <slot\n                name=\"item\"\n                onSlotchange={this.onItemsChange}\n              ></slot>\n            </div>\n          </div>\n        )}\n      </Host>\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]}